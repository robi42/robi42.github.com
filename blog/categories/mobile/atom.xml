<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mobile | Robi's Blog]]></title>
  <link href="http://robi42.github.com/blog/categories/mobile/atom.xml" rel="self"/>
  <link href="http://robi42.github.com/"/>
  <updated>2014-09-28T15:02:03+02:00</updated>
  <id>http://robi42.github.com/</id>
  <author>
    <name><![CDATA[Robert Thurnher]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin FTW?]]></title>
    <link href="http://robi42.github.com/blog/2012/09/24/xamarin-ftw/"/>
    <updated>2012-09-24T20:02:00+02:00</updated>
    <id>http://robi42.github.com/blog/2012/09/24/xamarin-ftw</id>
    <content type="html"><![CDATA[<p>Often, when developing a mobile app one wants to target iOS as well as Android (+ maybe MS' OS).</p>

<p>Now, this basically means developing the app from scratch and consequently maintaining it at least twice on different platforms, written in different languages (Objective-C and Java, that is), using different sets of tools etc.</p>

<p>Cumbersome and potentially error-prone. Well, there's a viable alternative:</p>

<p>With <a href="http://xamarin.com/">Xamarin</a> one can write mobile apps targetting iOS and Android in C# using .NET (and native) libraries, sharing code (business logic, data &amp; web service layers, utilities, ...) while creating fully native UIs built on each platform's own SDKs, providing access to all respective device capabilities.</p>

<p>In addition to that, there's for example <a href="http://blog.xamarin.com/2012/02/10/easily-create-ios-user-interfaces-with-monotouch-dialog/">MonoTouch.Dialog</a> making it easier and more fun to create table-based iOS UIs and for Android there's a useful visual <a href="http://docs.xamarin.com/android/tutorials/Designer_Walkthrough">UI design tool</a> within the MonoDevelop IDE. Plus, there's <a href="http://xamarin.com/mobileapi">Xamarin.Mobile</a> aimed at exposing an unified API facade for accessing common device features. All interesting stuff when used sensibly.</p>

<p>Here's some demo code (which is loosely based on samples from the recommendable book <a href="http://shop.oreilly.com/product/0636920024002.do">"Mobile Development with C#"</a>) showing how mentioned shared layers could benefit:</p>

<p>{% codeblock Simple model lang:csharp %}
public class Tweet
{</p>

<pre><code>public long     Id        { get; set; }
public DateTime CreatedAt { get; set; }
public string   Text      { get; set; }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock Simple REST API client lang:csharp %}
public class TwitterApiClient
{</p>

<pre><code>const string BaseUrl = "https://api.twitter.com/1/statuses/";

public void DoWithTweetsForUser(string username, Action&lt;IList&lt;Tweet&gt;&gt; callback)
{
    var webClient = new WebClient();
    var url = string.Format("{0}user_timeline.json?screen_name={1}",
                            BaseUrl, Uri.EscapeUriString(username));

    webClient.DownloadStringCompleted += (sender, e) =&gt; {
        var tweets = (from element in JsonValue.Parse(e.Result) as JsonArray
            let tweetData = element as JsonObject
            select new Tweet {
                Id        = tweetData["id"],
                CreatedAt = DateTime.ParseExact(tweetData["created_at"],
                                "ddd MMM dd HH:mm:ss zz00 yyyy", null),
                Text      = tweetData["text"],
            })
            .ToList();

        callback(tweets);
    };

    webClient.DownloadStringAsync(new Uri(url));
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock Exemplary user code lang:csharp %}
var apiClient = new TwitterApiClient();</p>

<p>apiClient.DoWithTweetsForUser("robi42", tweets => {</p>

<pre><code>foreach (var tweet in tweets) // Just for demo purpose.
    Debug.WriteLine("Tweet from {0}: {1}", tweet.CreatedAt, tweet.Text);
</code></pre>

<p>});
{% endcodeblock %}</p>

<p>And with .NET 4.5's new <a href="http://blogs.msdn.com/b/dotnet/archive/2012/04/03/async-in-4-5-worth-the-await.aspx">async features</a> landing in Monoland soon, related code will get even more convenient to write and handle.</p>

<p>Pretty neat, IMHO. What do you think?</p>
]]></content>
  </entry>
  
</feed>
